##学习笔记——第三题  
### 1. **UpdateData()与DoDataExchange()函数**    
* UpdateData() 是MFC的窗口函数，用来刷新数据的。  
操作系统会调用这个函数来初始化对话框中的数据，或者检索或者验证对话框中的数据。  
**UpdateData(TRUE)**
——刷新控件的值到对应的变量。(外部输入值交给内部变量)  
即：控件的值—>变量。  
**UpdateData(FALSE)**
—— 拷贝变量值到控件显示。(变量的最终运算结果值交给外部输出显示)  
即：变量值—>控件显示。  
* 而DoDataExchange函数其实是一项数据动态绑定技术，将对话框里的控件与相应的成员变量与控件绑定起来。  
其MSDN描述写到： Never call this function directly. It is called by the UpdateData member function. Call UpdateData to initialize a dialog box’s controls or retrieve data from a dialog box.  
此函数永远不被直接调用， 必须通过调用UpdateData()函数来调用DoDataExchange函数。所以在用到控件与关联的成员变量交换数据时，要首先调用UpdateData()函数。   
### 2. AfxMessageBox()与MessageBox()函数
* **MessageBox**是CWnd的类成员函数，比较正式，常用在要提交的应用程序版本中，可以控制标题内容。 

* **AfxMessageBox**比MessageBox简单一些，因为它是一个全局函数所以不需要对应的一个窗口类，但是不能控制消息框标题，常用于调试程序时的内部数据输出或警告。

    主要区别：MessageBox 如果在非CWnd类中使用则是API函数，使用起来非常不便，必须指定标题和样式。
而使用CWnd类的函数，只需一个内容参数就可以了。AfxMessageBox和CWnd类成员函数类似，使用起来很方便，因为是Afx 基于框架的函数。如果用MFC的话，应尽量使用AfxMessageBox

    Afx开头的都是全局函数，也就是说AfxMessageBox可以用于任何程序；而MessageBox只能用在CWnd及其派生类中  
### 3. CAsyncSocket类与CSocket类  
*  CAsyncSocket类是从MFC的根类CObject派生而来的。CAsyncSocket类封装了WinSock API，类中的成员函数也在形式上与WinSock API极为相似。每个CAsyncSocket对象代表一个Windows Socket对象，这个类基于程序员了解网络通讯的假设，目的是为了在MFC中使用WinSock。但程序员有责任处理诸如阻塞、字节顺序和在Unicode与多字节字符集(MBCS) 间转换字符的任务。  
* CSocket类派生自CAsyncSocket类，提供了比CAsyncSocket更高层的WinSock API接口。  
CSocket类和CSocketFile类可以与CArchive类一起合作来管理发送和接收的数据，这种协同模型使编程者不必管理套接字的细节，只要创建CSocket、CSocketFile和CArchive对象并绑定三者之间的关系，就相当于创建了一条从应用程序直达网络传输层的数据通道。  
CSocket对象有两种工作状态，即异步（非阻塞）和同步（阻塞）。  
* CAsyncSocket应避免使用阻塞操作，而应使用异步操作，编程者必须使用回调函数自行管理阻塞。CSocket类则是同步的，但它能利用Windows消息机制为编程者管理阻塞。  
### 4. 通知函数OnXxx()与对应的处理函数onXxx()  
* 编程者根据CAsyncSocket或CSocket派生自己的套接字类，用于负责通信。通过重写虚成员函数OnReceive、OnSend、OnAccept、OnConnect、OnClose等进行功能扩展。这些虚函数也称为套接字类的通知函数，这些函数都是回调函数，MFC框架调用他们将重要事件通知给套接字对象。  
*  CAsyncSocket的Create()函数，除了创建了一个SOCKET以外，还创建了个CSocketWnd窗口对象，并使用WSAAsyncSelect()将这个SOCKET与该窗口对象关联，以让该窗口对象处理来自Socket的事件(消息)，然而CSocketWnd收到Socket事件之后，只是简单地回调OnReceive()，OnSend()，OnAccept()等虚函数。**所以Onxxx()是 CAsyncSocket封装的消息函数,onxxx()才完成真正的接收。真正的处理函数应写在这些虚函数内。**
*   例如OnConnect()与onConnect()：  
   OnConnect()函数的MSDN解释：
Called by the framework to notify this connecting socket that its connection attempt is completed, whether successfully or in error.
框架调用此函数，通知连接套接字连接行为已完成，无论成功或出错。  
在对话框类的OnClickedButtonConnect()响应函数内调用Connect()进行连接，其结果会触发OnConnect()函数，通过参数nErrorCode是否为0来判断是否连接成功。如果连接成功的话，则转去执行对话框类下的处理函数onConnect()进行连接后的相应设置。  
 
		  
		//客户机已连接到服务器上
		void CClientDlg::onConnect(void)
		{
			GetDlgItem(IDC_EDIT_TOSERVER)->EnableWindow(TRUE);
			GetDlgItem(IDC_BUTTON_DISCONNECT)->EnableWindow(TRUE);
			GetDlgItem(IDC_BUTTON_SEND)->EnableWindow(TRUE);
		}
  
* 同理，客户端调用一次send函数会触发服务器端的OnReceive()函数，如果接受成功，则转去执行onReceive()函数，真正实现接受。


* OnReceive()的MSDN解释：Called by the framework to notify this socket that there is data in the buffer that can be retrieved by calling the Receive member function  
框架调用此函数来通知套接字，接受缓冲区里有数据，可以调用Receive 成员函数进行接收。

* OnClose的MSDN解释:
Called by the framework to notify this socket that the connected socket is closed by its process.  
框架调用此函数来通知套接字，连接套接字已被进程关闭  
### 5. 无法打开预编译头文件:“Debug\Client.pch”: No such file or directory
* **解决方法**：右键项目名称，选择“属性标签”点击属性，配置属性 -->  C/C++  --> 预编译头，在右边的菜单中选择 “创建/使用预编译头”中的“不使用预编译头文件”确定即可。  
* **原因分析**：      编译器一般都是以文件为单位进行编译，如果修改了工程中的一个文件，那么将导致所有文件都要从新编译，这样的编译将耗费很长时间。
      为了提高编译速度，将那些不常被修改，比较稳定，文件单独包含到一个指定的头文件中， 然后生成一个预编译头文件 *.pch 。 VC中默认的头文件为 stdAfx.h， 但光有头文件无法编译，所以还要用到 StdAfx.cpp。这样编译时，通过编译 stdAfx.cpp就把大部分系统头文件编译进来， Debug目录下便会产生一个 存储了预编译信息的 *.pch 文件。
      如果 *.pch文件损坏或者不存在，就会出现，题目所示的无法打开预编译头文件的错。
### 6. TCHAR和char的转换  
* 问题：客户端发送个位数给服务器，服务器正常加1回复，但若发10的话服务器会给回复2。  
* 服务器的处理过程是：服务器将接收缓冲区里的字符串取出转变为数字，用atoi()函数。若在1~19范围内则将数字加1，再将处理后的数字存入另一个字符串，回复给客户端。  
* 开始时以为是字符数组的问题，以为将字符数组的名字作为指针的话只会传入字符数组的第一个字符。  
另外，服务器的接收缓存buff的类型为TCHAR，而atoi()函数的参数要求为const *char，所以又试着直接将接收缓存的buff类型由TCHAR改成char,但是调试时发现，接收缓存buff的显示是buff[0]=“1”，buff[1]=“\0”，buff[2]=“0”。。。相当于客户端发送10，服务器只会将“1”读进去，所以客户端发10的话服务器会给回复2.。。可能是建项目的时候选择使用多字节符集的原因。后来百度了char和TCHAR类型的关系与类型转换，最终解决了问题。  
* char是C语言标准数据类型，字符型，一般一个字节。Windows为了消除各编译器的差别，重新定义了一些数据类型。CHAR为单字节字符。还有个WCHAR为Unicode字符，即不论中英文，每个字有两个字节组成。如果当前编译方式为ANSI(默认)方式，TCHAR等价于CHAR，如果为Unicode方式，TCHAR等价于WCHAR。  
* TCHAR 是为了统一多语言编码而设计的，可用于双字节字符串，使程序可以用于中日韩等国语言文字处理、显示。使编程方法简化。

* TCHAR转为char：  
`//*tchar是TCHAR类型指针，*_char是char类型指针 `  
 `TcharToChar (const TCHAR * tchar, char * _char)  `
`{  `
	   ` int iLength ;`  
	`//获取字节长度 `  
	`iLength = WideCharToMultiByte(CP_ACP, 0, tchar, -1, NULL, 0, NULL, NULL);    `
	`//将tchar值赋给_char   ` 
	`WideCharToMultiByte(CP_ACP, 0, tchar, -1, _char, iLength, NULL, NULL);   `
`}`  
* char转为TCHAR  
`CharToTchar (const char * _char, TCHAR * tchar) `
   `{ `
	    `int iLength ;  `
	  
	   ` iLength = MultiByteToWideChar (CP_ACP, 0, _char, strlen (_char) + 1, NULL, 0) ;  `
	   ` MultiByteToWideChar (CP_ACP, 0, _char, strlen (_char) + 1, tchar, iLength) ;  `
	`} `  
其中WideCharToMultiByte()函数功能是映射一个unicode字符串到一个多字节字符串。








　


 
  







